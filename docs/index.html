<!DOCTYPE html>
<html>
  <head>
    <title>npm & webpack + tooling</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);
      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# npm & webpack

---

# .center[Agenda]

- npm
	- Was ist npm?
	- Installation von npm
	- package.json
	- Installation von Paketen
	- Updaten von Paketen
	- Deinstallation von Paketen
	- Übertragen des eigenen Programmes
- webpack
  - Was ist Webpack
  - setup
  - modules
  - loaders
  - code splitting
  - plugins
  - development

---

# .center[Was ist npm?]

- npm steht für Node Package Manager
- Es wird genutzt um Module und Pakete einfach zu installieren
- Macht es für Entwickler einfach Code zu teilen und Code anderer zu nutzen

---

# .center[Installation npm]

- npm wird zusammen mit Node.js installiert
	- Eine Version ohne Node.js gibt es nicht
- Für Windows Systeme einfach https://nodejs.org/ besuchen und downloaden
- Linux installation erfolgt über den Paketemanager

---

# .center[package.json]

- Wird erstellt mit `npm init`
	- Um alle defaults zu übernehmen Nutzt man `npm init -y`
- package.json ist eine Konfigurationsdatei und es werden Dinge gespeichert wie
	- Name der Applikation
	- Version
	- Beschreibung
	- Autor
	- Abhängigkeiten
- Die Abhängigkeiten stellen Pakete dar welche zum Projekt hinzugefügt wurden wenn bei der Installation alles richtig gemacht wurde

---

# .center[package.json - Beispiel]

```javascript
{
	"name": "app",
	"version": "1.0.0",
	"description": "",
	"main": "index.js",
	"scripts": {
		"test": "echo \""Error: no test specified\" && exit 1
	},
	"keywords": [],
	"author": ""
	"license": "ISC",
	"dependencies": {
		"lodash": "^4.17.10"
	}
}
```

---

# .center[Installation von Paketen]

## Lokal

- Lokale Pakete werden in dem Ort installiert in dem der Installationsbefehl ausgeführt wurde
- Pakete werden mit dem Befehl `npm install 'Paketname'` installiert
	- Zum Beispiel `npm install lodash`
	- Besser ist aber `npm install lodash --save`
	- Oder `npm install lodash --save-dev`
- Durch nutzen von `--save`/`--save-dev` wird das installierte Paket in der package.json unter dependencies/devDependencies gespeichert

---

# .center[Installation von Paketen]

## Global

- Funktioniert praktisch wie Lokale installation
	- `npm install lodash -g`

## Bestimmte Version

- Installation einer Bestimmten Version Funktioniert mit
	- `npm install lodash@4.17.4 --save`

---

# .center[Update von Paketen]

- Das Aktualisieren von Paketen funktioniert mit
	- `npm update lodash --save`
- Wichtig ist das man hier auch wieder entweder `--save` oder `--save-dev` nutzt

---

# .center[Deinstallation von Paketen]

## Local

- Deinstallation von Paketen mit dem Befehl
	- `npm remove lodash --save`
- Wichtig ist das man hier auch wieder entweder `--save` oder `--save-dev` nutzt damit der Eintrag aus der package.json entfernt wird

## Global

- Deinstallieren von globalen Paketen mit einem `-g`
	- `npm remove -g lodash`

---

# .center[Übertragen des eigenen Programmes]

- Das Programm wird installiert durch den Befehl
	- `npm install` oder `npm install --production`
- Wenn die Abhängigkeiten in der Pakete richtig in der package.json eingetragen sind werden sie automatisch heruntergeladen
	- Es kann aber nicht einfach die neuste Version der Pakete geladen werden
	- Dadurch kann es Probleme bei der kompatibilität geben

```javascript
"dependencies": {
		"lodash": "^4.17.10"
	}
```

- Es gibt unterschiedliche Wege zu zeigen welche Version man möchte
	- `"lodash": "*"` -> Neuste Version
	- `"lodash": "^4.17.10"` -> Version 4.x.x
	- `"lodash": "~4.17.10"` -> Version 4.17.x
	- `"lodash": "4.17.10"` -> Nur Version 4.17.10

---

# .center[Was ist Webpack?]

Webpack ist ein Modulbündler, dessen Hauptzweck das Bündlen von javascript-Dateien
für die Browsernutzung ist. Es packt, transformiert oder bündelt aber auch nahezu
jede Resource.

---

# .center[setup]

- zunächst muss webpack mittels npm installiert werden
```shell
mkdir webpack-demo && cd webpack-demo
npm init -y
npm install --save-dev webpack webpack-cli
```
- anschließend muss folgende Ordnerstruktur erstellt werden

```
  webpack-demo
  |- package.json
  |- webpack.config.js
  |- /src
    |- index.js
  |- /dist
    |- index.html

```
- folgend wird auf die einzelnen Dateien eingegangen
---

# .center[setup]

### dist/index.html
```html
<!doctype html>
<html>
  <head>
    <title>Ahoi</title>
  </head>
  <body>
    <script src="bundle.js"></script>
  </body>
</html>
```
### src/index.js
```javascript
const root = document.createElement("div")
root.innerHTML = `<p>Hello Webpack.</p>`
document.body.appendChild(root)
```
---

# .center[setup]

### webpack.config.js
```javascript
const path = require('path')
module.exports = {
  entry: './src/index.js',
  output: {
    filename: 'bundle.js',
    path: path.resolve(__dirname, 'dist')
  }
}
```
### package.json
```json
  {
    ...
    "scripts": {
     "test": "echo \"Error: no test specified\" && exit 1"
     "develop": "webpack --mode development --watch",
     "build": "webpack --mode production"
   },
   ...
  }
```
---
# .center[setup]

- man kreiert das Bundle mit
```shell
npm run develop
```
- nun kann man die *dist/index.html* im Browser öffnen, welche uns mit *Ahoi* begrüßt
- *webpack* erzeugt *dist/bundle.js*, es ist nun in der Lage das Projekt
für alle Browser zu erzeugen
- mit *npm run build* wird das Bundle im *production mode* kompiliert
- *development mode* ist optimiert für schnelles Bauen und Debugging
- *production mode* ist optimiert für schnelle Ausführung zur Laufzeit und die
  Ausgabedatei-Größe

---

# .center[modules]

Mit Modulen kann man große Programme in kleinere splitten.
Mittels *import* und *export* kann man Module hinzufügen.

---
# .center[modules]

###src/index.js
```javascript
import { groupBy } from "lodash-es"
import people from "./people"
const managerGroups = groupBy(people, "manager")
const root = document.createElement("div")
root.innerHTML = `<pre>${JSON.stringify(managerGroups, null, 2)}</pre>`
document.body.appendChild(root)
```
---
# .center[modules]
###src/people.js
```javascript
const people = [
  {
    manager: "Jen",
    name: "Bob"
  },
  {
    manager: "Jen",
    name: "Sue"
  },
  {
    manager: "Bob",
    name: "Shirley"
  }
]
export default people
```
---
# .center[modules]

Wenn man nun mit *npm run develop* webpack laufen lässt, und die *index.html*
aktualisiert, sieht man ein Array von Leuten nach den Managern sortiert. Man hat
eine Methode aus dem importierten Modul benutzt.

---
# .center[loaders]

Mit Loadern kann man Preprocessoren über Dateien laufen lassen, sobald sie importiert
werden. So kann man statische Resourcen bündeln.

Wenn man z.B Babel installiert kann man seine .js Dateien transpilen

```shell
npm install --save-dev "babel-loader@^8.0.0-beta" @babel/core @babel/preset-env
```

---
# .center[loaders]

### webpack.config.js

```javascript
const path = require('path')

module.exports = {
  entry: './src/index.js',
  output: {
    filename: 'bundle.js',
    path: path.resolve(__dirname, 'dist')
  },
  module: {
    rules: [
    {
      test: /\.js$/,
      exclude: /(node_modules|bower_components)/,
      use: {
        loader: 'babel-loader',
      }
    }
    ]
  }
}
```
---
# .center[loaders]

### .babelrc

```JSON
{
  "presets":[
  ["@babel/env", {
    "modules": false
  }]
  ],
  "plugins": ["syntax-dynamic-import"]
}
```

Diese Konfiguration z.B. verhindert das import und export Dateien zu ES5 transpiliert
werden.

---
# .center[loaders]

### Verkettungen

Loader können auch verkettet werden, um eine Reihe an Transformationen durchzuführen.

```shell
npm install --save-dev style-loader css-loader sass-loader node-sass
```

---
# .center[loaders]

### webpack.config.js

```javascript
module.exports = {
  ...
  module: {
    rules: [
    ...
    {
      test: /\.scss$/,
      use: [{
        loader: 'style-loader'
      },{
        loader: 'css-loader'
      },{
        loader: 'sass-loader'
      }]
    }
    ]
  }
}
```
---
# .center[loaders]

Die Loader werden in umgekehrter Reihenfolge abgearbeitet:
* **sass-loader**:  transformiert Sass zu CSS
* **css-loader**:   parst CSS zu JavaScript löst alle Abhängigkeiten auf
* **style-loader**: schreibt die CSS in einen **style** tag im Dokument

Gründe um das zu tun, könnten sein:
* einige Komponenten beruhen auf bestimmten Dateien, so können sie bequem gebündelt
importiert werden
* toter Code wird eliminiert, sobald eine Komponente nicht gebraucht wird, wird auch
die css Datei entfernt, da alles gebündelt ist
* HTTP Requests werden minimiert, wenn man den Code gut bündelt und splittet

Ein weiterer Anwendungsfall für Loader sind Bilder, zumindest für kleinere Bilder
kann man die Source als String im JavaScript hinterlegen, so müssen sie nicht zur
Laufzeit erst geladen werden sonder können vorgeladen werden.

---

# .center[codes splitting]

Mit code splitting kann man sein Projekt in kleinere Teile aufteilen, so muss nicht
zu Beginn alles geladen werden, sondern nur nach Bedarf nachgeladen.

---
# .center[plugins]

Plugins sind ähnlich wie loaders, jedoch transformieren sie nicht einzelne Dateien,
sondern größere Stücke Code

Ein Beispiel dafür sind "modes", so kann man verschiedene Pakete laden je nach Modus.

---
# .center[development]

Mit dem **webpack-dev-server** bekommt man einen kleinen simplen Server, mit
welchem man live Änderungen der Seite angezeigt bekommt.

Das **HotModuleReplacement** kann sogar live Module zur Laufzeit austauschen.
Das kann eine Menge Zeit sparen bei der Entwicklung von Single Page Apps.

---

class: center, middle

# Vielen Dank für die Aufmerksamkeit
(Artem Kul'bashny und Slavko Dick)


.footer[...
weiter geht es mit tooling
...]

---

class: center, middle

# Tests

---

# .center[Agenda]

- Testen?
- Funktionaler Code
- NodeJS testen
  - Mocha
  - Chai
  - SinonJS
  - spies
  - stubs
  - mocks
  - Asynchrones Testen
    - Callbacks
    - Promises
- Snapshot Tests mit Jest
---

# .center[Testen?]

- Warum sollte ich testen?
	- Sicherstellen der Programmfunktionalität
- Was für tests gibt es?
	- Unit tests -> prüft die funktionalität von isolierten Code
	- Integration tests -> prüft den fluss von Informationen zwischen Komponenten
	- Functional tests -> prüft das allgemeine Verhalten des Programmes
- Wann sollte ich testen?
	- Immer
	- Vor dem schreiben des eigentlichen Code

---

# .center[Funktionaler Code]

- Wie gut man testen kann ist abhängig davon wie gut der Code geschrieben wurde
- Funktionaler Code ist Code der so gekapselt wie möglich ist
	- Ohne große abhängigkeiten lässt sich Code leichter testen
	- Globale Variablen sollten vermieden werden
		- Abhängigkeiten werden erzeugt wenn mehrere Funktionen auf eine Variable zugreifen
- Nutzung "purer" Funktionen ist notwendig
	- Verlässt sich nicht auf externe Variablen
	- Verändert keine externen Variablen
	- Gibt immer den selben output für den selben input

---

# .center[Mocha]

- Mocha ist ein Testrunner, dieses Tool führt Tests aus (npm Installation)
- wenn es installiert ist, kann man eine Ordnerstruktur anlegen, worin man die Tests
ablegt
- dann kann man alle Tests in dieser Ordnerstruktur mit Mocha laufen lassen
- mit Mocha muss man bei ArrowFunctions aufpassen, wegen "this", welches von Mocha nicht
nach ES6 Standart behandelt wird

---
# .center[Chai]

- Chai ist eine Assertion Bibliothek
- sie erweitert das einfache Assert, welches in NodeJS enthalten ist um weitere Assertions

---
# .center[SinonJS]
mit SinonJS kann man zum Testen auf spies, stubs und mocks zurückgreifen

###spies
- kreieren Fakefunktionen um zu testen wie oft Aufrufe gemacht werden
- man kann sie aber auch auf reele Funktionen anwenden um ihre Aufrufe zu tracken

### stubs
- damit kann man Funktionen ersetzen und ihr Verhalten manipulieren
- so können wir das Verhalten genau kontrolieren um unsere Szenarien zu Testen

### mocks
- sind Fake Methoden mit vorprogrammiertem Verhalten
- damit kann man Klassen testen, welche andere Klassen aufrufen

---
# .center[spies]

Beispiel
```javascript
module.exports = {
  // A func that takes in two parameters `req` and `res` [request, response]
  getIndexPage: (req, res) => {
    res.send("Hey");
  }
}
```
---
# .center[spies]

```javascript
const chai = require("chai");
const expect = chai.expect;
// import sinon
const sinon = require("sinon");
const indexPage = require("../../controllers/app.controller.js");

describe("getIndexPage", function() {
  it("should send hey", function() {
    let req = {}
    // Have `res` have a send key with a function value coz we use `res.send()` in our func
    let res = {
      // replace empty function with a spy
      send: sinon.spy()
    }

    indexPage.getIndexPage(req, res);
    // let's see what we get on res.send
    console.log(res.send);
    // `res.send` called once
    expect(res.send.calledOnce).to.be.true;
    // expect to get argument `bla` on first call
    expect(res.send.firstCall.args[0]).to.equal("bla");
  });
});
```
---
# .center[stubs]
Beispiel
```JavaScript
module.exports = {
  // A func that takes in two parameters `req` and `res` [request, response]
  getIndexPage: (req, res) => {
    if (req.user.isLoggedIn()) {
      return res.send("Hey");
    }
    res.send("Ooops. You need to log in to access this page");
  }
}
```
---

# .center[stubs]

- zunächst werden die Module importiert

```javascript
const chai = require("chai");
const expect = chai.expect;
// import sinon
const sinon = require("sinon");
const indexPage = require("../../controllers/app.controller.js");

```

---

# .center[stubs]

- hier wird mittels stub immer isLoggedIn true zurückgegeben

```javascript
describe("AppController", function()  {
  describe("getIndexPage", function() {
    it("should send hey when user is logged in", function() {
      // instantiate a user object with an empty isLoggedIn function
      let user = {
        isLoggedIn: function(){}
      }

      // Stub isLoggedIn function and make it return true always
      const isLoggedInStub = sinon.stub(user, "isLoggedIn").returns(true);

      // pass user into the req object
      let req = {
        user: user
      }

      // Have `res` have a send key with a function value coz we use `res.send()` in our func
      let res = {
        // replace empty function with a spy
        send: sinon.spy()
      }
```

---
# .center[stubs]

- zuletzt überprüfen wir ob sich die Funktion verhält wie erwartet

```javascript
indexPage.getIndexPage(req, res);
// let's see what we get on res.send
// console.log(res.send);
// `res.send` called once
expect(res.send.calledOnce).to.be.true;
expect(res.send.firstCall.args[0]).to.equal("Hey");

// assert that the stub is logged in at least once
expect(isLoggedInStub.calledOnce).to.be.true;
    });
  });
});
```

---
# .center[mocks]

- Beispiel (Module müssen importiert werden)

```javascript
describe("AppController", function()  {
  describe("getIndexPage", function() {
    it("should send hey when user is logged in", function() {
      // instantiate a user object with an empty isLoggedIn function
      let user = {
        isLoggedIn: function(){}
      }

      // Stub isLoggedIn function and make it return true always
      const isLoggedInStub = sinon.stub(user, "isLoggedIn").returns(true);

      // pass user into the req object
      let req = {
        user: user
      }

      // Have `res` have a send key with a function value coz we use `res.send()` in our func
      let res = {
        send: function(){}
      }

```

---

# .center[mocks]

```javascript
      // mock res
      const mock = sinon.mock(res);
      // build how we expect it t work
      mock.expects("send").once().withExactArgs("Hey");

      indexPage.getIndexPage(req, res);
      expect(isLoggedInStub.calledOnce).to.be.true;

      // verify that mock works as expected
      mock.verify();
    });
  });
});
```

---

# .center[Asynchrones Testen]

## Callbacks
- Probleme bei asyncronem Code, der Test ist vielleicht schon fertig bevor alle
Callbacks wieder da sind
- Lösung mit **done** keyword in **it** Funktion

```JavaScript
...
it("should return `You get a sweet :)` if `true` is passed in", function(done) {
...
```

- damit weiß mocka, dass es auf die Funktion warten muss

---

```javascript
const chai = require("chai");
const expect = chai.expect;

// This is just an async func that takes in a bool
// and calls a callback that returns a some message
// depending on the bool value
function someMadeUpAyncFunc(boolValue, cb) {
  setTimeout(function() {
    cb(boolValue ? "You get a sweet :)" : "You get nothing!!")
  }, 0);
}

// Added the `only` tag to have only this set of tests to run
describe.only("AsyncTest", function()  {
  it("should return `You get a sweet :)` if `true` is passed in", function(done) {
    someMadeUpAyncFunc(true, function(sweetCheck){
      expect(sweetCheck).to.equal("You get a sweet :)");
      done();
    });
  });

  it("should return `You get nothing!!` if `false` is passed in", function(done) {
    someMadeUpAyncFunc(false, function(sweetCheck){
      // Let's fail it on purpose just to see what happens
      expect(sweetCheck).to.equal("You get a sweet :)");
      done();
    });
  });
});
```

---

# .center[Asynchrones Testen]

## Promises

- man braucht das Paket **chai-as-promised**
- wenn man dann einen Promises testet benutzt man dann eine neue Assertion: **eventually**

---

```javascript
const chai = require("chai");
const expect = chai.expect;
chai.use(require("chai-as-promised"));

// This is just an async func that takes in a bool
// and that returns a promise
function someMadeUpAyncFunc(boolValue, cb) {
  return new Promise(function(resolve){
    setTimeout(function() {
      resolve(boolValue ? "You get a sweet :)" : "You get nothing!!")
    }, 0);
  })
}

// Added the `only` tag to have only this set of tests to run
describe.only("AsyncTest", function()  {
  it("should return `You get a sweet :)` if `true` is passed in", function() {
    return expect(someMadeUpAyncFunc(true)).to.eventually.equal("You get a sweet :)");
  });

  it("should return `You get nothing!!` if `false` is passed in", function() {
    return expect(someMadeUpAyncFunc(false)).to.eventually.equal("You get nothing!!");
  });
});
```

---

# .center[Jest]

Was sind Snapshot Tests?  - Mit Snapshot Tests kann man ein "Bild" des funktionierenden
Codes machen und nach den Änderungen, überprüfen ob der Code noch immer so funktioniert.

Wenn man einen Code hat, kann man ein Abbild davon erstellen. Wenn man den Code dann
ändert, testet man das mit dem Snapshot Test und wenn sich der Code anders verhält,
schlägt der Test fehl.

Dann kann man entweder zurück zu dem ursprünglichen Code wechseln oder aber den
neuen Code als neues Abbild setzen.

Snapshot Testing setzt voraus, das man funktionierenden Code hat und erst danach
anfängt zu testen. Das ist nicht test-driven-development.

Es ist nur ein Tool in der Sammlung, es nicht gedacht als Allzweckwerkzeug.

---

# .center[Jest]

- Jest ist ein Testrunner
- es kommt mit expectations, mocks und spies
- und es hat auch Snapshot Testing
- Jest testet nur die Dateien, die geändert wurden
- und es testet auch die Dateien, welche die geänderten benutzen
- Jest zeigt nicht nur das ein Test fehlschlägt, sondern auch was geändert wurde
---

class: center, middle

# Vielen Dank für die Aufmerksamkeit
(Artem Kul'bashny und Slavko Dick)


    </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create();
    </script>
  </body>
</html>
