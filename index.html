<!DOCTYPE html>
<html>
  <head>
    <title>ES6 Vorstellung</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# ES6

---

# Agenda

1. Einführung
2. Pfeile
3. Klassen
4. Erweiterte Objektliterale
5. Vorlage Strings
6. Destrukturierung
7. default + rest + spread
8. let + const
9. iterators + for..of
10. generators
11.	unicode
12.	modules
13.	module loaders
14	map + set + weakmap + weakset
15. proxies
16.	symbols
17.	subclassable built-ins
18.	promises
19.	math + number + string + array + object APIs
20.	binary and octal literals
21.	reflect api
22.	tail calls

---

# Einführung

ES6 ist die aktuellste Version des ECMAScript Standarts. ES6 hat einge signifikante Änderungen
erfahren. Es bringt einige neue Features.

---

# Pfeile

Pfeile sind eine Funktion mit der Syntax =>. Sie sind syntaktisch ähnlich wie die entsprechenden
Funktionen in C#, Java 8 und CoffeeScript. Sie unterstützen sowohl Anweisungsblockkörper
als auch Ausdruckskörper, die den Wert des Ausdrucks zurückgeben. Im Gegensatz zu
Funktionen teilen sich Pfeile die gleiche lexikalische Bedeutung wie ihr umgebender Code.

---

# Klassen

ES6-Klassen sind einfach über das Prototyp-basierte OO-Muster. Eine einzige komfortable
deklarative Form erleichtert die Verwendung von Klassenmustern und fördert die
Interoperabilität. Klassen unterstützen prototypische Vererbung, Superaufrufe,
Instanz- und statische Methoden und Konstruktoren.

---

# Erweiterte Objektliterale

Objektliterale wurrden erweitert, um das Setzen des Prototyps bei der Konstruktion zu
unterstützen, kurz für foo: foo-Zuweisungen, Definieren von Methoden, Ausführen von
Superaufrufen und Berechnen von Eigenschaftsnamen mit Ausdrücken. Zusammen bringen
sie auch Objektliterale und Klassendeklarationen näher zusammen und lassen objektbasiertes
Design von einigen der gleichen Annehmlichkeiten profitieren.

---

# Vorlage Strings

Template-Strings sind toll für den Aufbau von Strings. Dies ist vergleichbar mit
Stringinterpolationsfunktionen in Perl, Python und mehr. Optional kann ein tag hinzugefügt
werden, um die Stringkonstruktion anzupassen, um Injektionsangriffe zu vermeiden oder aus
Stringinhalten übergeordnete Datenstrukturen aufzubauen.

---

# Destrukturierung

Die Destrukturierung ermöglicht das Binden mittels Pattern-Matching, mit Unterstützung für
das Matching von Arrays und Objekten. Die Destrukturierung ist Fail-Soft, ähnlich wie bei
der Standard Objektsuche foo["bar"], und erzeugt undefinierte Werte, wenn sie nicht
gefunden wird.

---

# default + rest + spread

Callee-ausgewertete Defaultparameterwerte. Verwandelt ein Array in aufeinanderfolgende
Argumente in einem Funktionsaufruf. Bindet nachgestellte Parameter an ein Array. Rest
ersetzt die Notwendigkeit von Argumenten und adressiert häufige Fälle direkter.

---

# let + const

Blockbedingter Geltungsbereich für Bindungskonstrukte. let ist die neue var. const ist eine
Einzelzuordnung. Statische Einschränkungen verhindern die Verwendung vor der
Zuweisung.

---

# iterators + for..of

Iterator-Objekte ermöglichen benutzerdefinierte Iterationen wie CLR IEnumerable oder Java
Iterable. Verallgemeinern Sie for...in zur benutzerdefinierten iteratorbasierten Iteration mit
for..of. Es ist nicht erforderlich, ein Array zu realisieren, um Designmuster wie LINQ zu
verwenden.

---

#	generators

Generatoren vereinfachen das Iterator-Authoring durch Funktion* und Ausbeute. Eine als
Funktion* deklarierte Funktion gibt eine Generator-Instanz zurück. Generatoren sind
Subtypen von Iteratoren, die zusätzliche next und throw enthalten. Diese ermöglichen den
Rückfluss von Werten in den Generator, yield gibt einen Wert
(oder throws) zurück.

Hinweis: Kann auch verwendet werden, um die 'await'-ähnliche asynchrone Programmierung
zu aktivieren.

---

# unicode

Nicht brechende Ergänzungen zur Unterstützung von vollständigem Unicode, einschließlich
neuer Unicode-Literalform in Strings und neuem RegExp u-Modus zur Behandlung von
Codepunkten sowie neuer APIs zur Verarbeitung von Strings auf der Ebene der
21-Bit-Codepunkte. Diese Ergänzungen unterstützen die Erstellung von globalen
Anwendungen in JavaScript.

---

#	modules

Sprachliche Unterstützung von Modulen zur Definition von Komponenten. Kodiert Muster
von gängigen JavaScript-Modulladern (AMD, CommonJS). Laufzeitverhalten, definiert
durch einen vom Host definierten Standardlader. Implizites asynchrones Modell - kein Code
wird ausgeführt, bis die angeforderten Module verfügbar und verarbeitet sind.

---

#	module loaders

Unterstützung von Modulladern:

* Dynamisches Laden
* Zustandsisolierung
* Globale Namensraumisolierung
* Kompilierhaken
* Verschachtelte Virtualisierung

Der Standardmodullader kann konfiguriert werden, und neue Lader können konstruiert
werden, um Code in isolierten oder eingeschränkten Kontexten auszuwerten und zu laden.

---

#	map + set + weakmap + weakset

Effiziente Datenstrukturen für gängige Algorithmen. WeakMaps bietet leckfreie
Objektschlüssel verwendende Tabellen.

---

#	proxies

Proxies ermöglichen die Erstellung von Objekten mit dem gesamten Verhaltensspektrum,
das für Hostobjekte zur Verfügung steht. Kann für Abfangen, Objektvirtualisierung,
Logging/Profiling, etc. verwendet werden.
---

#	symbols

Symbole ermöglichen die Zugriffskontrolle auf den Objektzustand. Symbole erlauben es,
Eigenschaften entweder mit einem String (wie in ES5) oder einem Symbol zu kodieren.
Symbole sind ein neuer primitiver Typ. Optionaler Beschreibungsparameter, der beim
Debuggen verwendet wird - aber nicht Teil der Identität ist. Symbole sind einzigartig
(wie Gensym), aber nicht privat, da sie über Reflexionsfunktionen wie
Object.getOwnPropertySymbols belichtet werden.

---

#	subclassable built-ins

In ES6 können eingebaute Elemente wie Array, Date und DOM-Elemente untergeordnet
werden.

Die Objektkonstruktion für eine Funktion namens Ctor verwendet nun zwei Phasen
(beide virtuell versendet):

* Rufen Sie Ctor[@@create] auf, um das Objekt zuzuweisen und ein spezielles Verhalten
zu installieren.
* Aufruf des Konstruktors bei neuer Instanz zur Initialisierung

Das bekannte @@create-Symbol ist über Symbol.create verfügbar. Built-Ins zeigen nun
ihr @@create explizit an.

---

#	promises

Promises sind eine Bibliothek für die asynchrone Programmierung. Promises sind eine
erstklassige Darstellung eines Wertes, der in Zukunft zur Verfügung gestellt werden kann.
Promises werden in vielen bestehenden JavaScript-Bibliotheken verwendet.

---

#	math + number + string + array + object APIs

Viele neue Bibliothekserweiterungen, darunter Kern-Mathe-Bibliotheken,
Array-Konvertierungshilfen, String-Helfer und Object.assign zum Kopieren.

---

#	binary and octal literals

Zwei neue numerische Literalformen werden für binär (b) und oktal (o) hinzugefügt.

---

#	reflect api

Vollständige Reflection-API, die die Meta-Operationen auf Runtime-Ebene auf Objekten
anzeigt. Dies ist praktisch das Gegenteil der Proxy-API und erlaubt Aufrufe, die den
gleichen Meta-Operationen entsprechen wie die Proxy-Traps. Besonders nützlich bei der
Implementierung von Proxies.

---

#	tail calls

Aufrufe in der Endposition sind garantiert nicht unbegrenzt wachsend. Macht rekursive
Algorithmen gegenüber unbegrenzten Eingaben sicher.

    </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create();
    </script>
  </body>
</html>
